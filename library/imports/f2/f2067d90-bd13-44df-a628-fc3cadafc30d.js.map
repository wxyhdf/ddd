{"version":3,"sources":["..\\..\\..\\..\\..\\assets\\Script\\common/assets\\Script\\common\\assetLoader.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,iCAAgC;AAChC,IAAiB,WAAW,CA2L3B;AA3LD,WAAiB,WAAW;IACxB;QAII,kBAAY,GAAY,EAAE,IAAsB,EAAE,KAAW;YACzD,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;YACf,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;YACjB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACvB,CAAC;QACL,eAAC;IAAD,CATA,AASC,IAAA;IATY,oBAAQ,WASpB,CAAA;IAED;QAcI,mBAAY,OAAqD;YAbjE,UAAU;YACF,aAAQ,GAAyB,aAAK,CAAC,MAAM,CAAC,WAAW,CAAuB,aAAK,CAAC,IAAI,CAAC,CAAC;YACpG,YAAY;YACJ,WAAM,GAAyB,IAAI,aAAK,CAAC,IAAI,EAAY,CAAC;YAClE;;eAEG;YACK,eAAU,GAAW,CAAC,CAAC;YAC/B;;eAEG;YACK,cAAS,GAAgD,IAAI,CAAC;YAGlE,IAAI,OAAO;gBAAE,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC;QAC1C,CAAC;QACD;;;WAGG;QACH,uBAAG,GAAH,UAAO,GAAG;YACN,IAAI,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,GAAG,IAAI,GAAG,EAAf,CAAe,CAAC,CAAC;YACnE,OAAO,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC;QACxC,CAAC;QACD;;;;WAIG;QACH,8BAAU,GAAV,UAAW,GAAW,EAAE,IAAqB;YACzC,iBAAiB;YACjB,IAAI,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,GAAG,IAAI,GAAG,EAAf,CAAe,CAAC,CAAC;YACjE,UAAU;YACV,IAAI,CAAC,MAAM;gBAAE,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,QAAQ,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,CAAC;QAC1D,CAAC;QACD;;WAEG;QACG,yBAAK,GAAX;2CAAe,OAAO;;;oBAClB,sBAAO,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;4BAC/B,KAAI,CAAC,UAAU,GAAG,CAAC,CAAC;4BACpB,IAAI,IAAI,GAAyB,IAAI,aAAK,CAAC,IAAI,EAAY,CAAC;oDACjD,IAAI;gCAEX,IAAI,GAAG,GAAG,KAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,GAAG,IAAI,IAAI,CAAC,GAAG,EAAjB,CAAiB,CAAC,CAAC;gCAC/D,eAAe;gCACf,IAAI,GAAG,IAAI,GAAG,CAAC,KAAK,KAAK,SAAS,IAAI,GAAG,CAAC,KAAK,KAAK,IAAI;oCAAE,KAAI,CAAC,UAAU,EAAE,CAAC;;oCACvE,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;;4BALxB,KAAmB,UAAW,EAAX,KAAA,KAAI,CAAC,MAAM,EAAX,cAAW,EAAX,IAAW;gCAAzB,IAAM,IAAI,SAAA;wCAAJ,IAAI;6BAMd;4BACD,aAAa;4BACb,IAAI,KAAI,CAAC,SAAS;gCAAE,KAAI,CAAC,SAAS,CAAC,KAAI,CAAC,UAAU,EAAE,KAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;4BACxE,IAAI,KAAI,CAAC,UAAU,IAAI,KAAI,CAAC,MAAM,CAAC,MAAM;gCAAE,OAAO,EAAE,CAAC;iCAChD;gCACD,KAAiB,UAAI,EAAJ,aAAI,EAAJ,kBAAI,EAAJ,IAAI,EAAE;oCAAlB,IAAI,IAAI,aAAA;oCACT,WAAW,CAAC,GAAG,CAAmB,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,UAAC,GAAG;wCAC5D,QAAQ;wCACR,KAAI,CAAC,UAAU,EAAE,CAAC;wCAClB,aAAa;wCACb,IAAI,KAAI,CAAC,SAAS;4CAAE,KAAI,CAAC,SAAS,CAAC,KAAI,CAAC,UAAU,EAAE,KAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;wCACxE,0BAA0B;wCAC1B,IAAI,KAAI,CAAC,UAAU,IAAI,KAAI,CAAC,MAAM,CAAC,MAAM;4CAAE,OAAO,EAAE,CAAC;oCACzD,CAAC,CAAC,CAAA;iCACL;6BACJ;wBACL,CAAC,CAAC,EAAC;;;SACN;QACL,gBAAC;IAAD,CAnEA,AAmEC,IAAA;IAnEY,qBAAS,YAmErB,CAAA;IACD;;OAEG;IACH;QAAA;QAsCA,CAAC;QAnCG;;;;WAIG;QACU,eAAG,GAAhB,UAAoB,GAAW,EAAE,CAAkB;2CAAG,OAAO;;;oBACzD,sBAAO,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;4BAC/B,0DAA0D;4BAE1D,qBAAqB;4BACrB,IAAI,MAAM,GAAG,KAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,GAAG,IAAI,GAAG,EAAf,CAAe,CAAC,CAAC;4BACnE,IAAI,MAAM,IAAI,MAAM,CAAC,KAAK,IAAI,SAAS,IAAI,MAAM,CAAC,KAAK,IAAI,IAAI,EAAE;gCAC7D,UAAU;gCACV,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;6BACzB;iCAAM;gCACH,oBAAoB;gCACpB,EAAE,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,EAAE,UAAC,KAAK,EAAE,GAAM;oCACpC,IAAI,IAAI,GAAG,KAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,GAAG,IAAI,GAAG,EAAf,CAAe,CAAC,CAAC;oCACjE,gBAAgB;oCAChB,IAAI,IAAI,EAAE;wCACN,aAAa;wCACb,IAAI,CAAC,KAAK,GAAG,GAAG,CAAC;qCACpB;yCAAM;wCACH,aAAa;wCACb,KAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,QAAQ,CAAC,GAAG,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;qCAChD;oCACD,IAAI,KAAK,EAAE;wCACP,MAAM,CAAC,KAAK,CAAC,CAAC;qCACjB;yCAAM;wCACH,OAAO,CAAC,GAAG,CAAC,CAAC;qCAChB;gCACL,CAAC,CAAC,CAAA;6BACL;wBACL,CAAC,CAAC,EAAC;;;SACN;QApCD,UAAU;QACH,oBAAQ,GAAG,aAAK,CAAC,MAAM,CAAC,WAAW,CAAuB,aAAK,CAAC,IAAI,CAAC,CAAC;QAoCjF,kBAAC;KAtCD,AAsCC,IAAA;IAtCY,uBAAW,cAsCvB,CAAA;IAED;;OAEG;IACH;QAGI;YACI,IAAI,CAAC,aAAa,GAAG,IAAI,EAAE,CAAC,QAAQ,EAAE,CAAC;QAC3C,CAAC;QACD;;;;WAIG;QACG,iCAAW,GAAjB,UAAqB,GAAW,EAAE,CAAkB;2CAAG,OAAO;;;oBAC1D,sBAAO,IAAI,OAAO,CAAU,UAAC,OAAO,EAAE,MAAM;4BACxC,IAAI,IAAI,GAAG,IAAI,CAAC;4BAChB,IAAI,KAAI,CAAC,aAAa,CAAC,IAAI,EAAE,GAAG,CAAC,EAAE,EAAE,2BAA2B;gCAC5D,IAAI,GAAG,KAAI,CAAC,aAAa,CAAC,GAAG,EAAE,CAAC;gCAChC,OAAO,CAAC,IAAI,CAAC,CAAC;6BACjB;iCAAM,EAAE,mDAAmD;gCACxD,WAAW,CAAC,GAAG,CAAI,GAAG,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,UAAC,GAAG;oCAChC,IAAI,GAAG,EAAE,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;oCAC3B,OAAO,CAAC,IAAI,CAAC,CAAC;gCAClB,CAAC,EAAE,UAAC,KAAK;oCACL,MAAM,CAAC,KAAK,CAAC,CAAC;gCAClB,CAAC,CAAC,CAAA;6BACL;wBACL,CAAC,CAAC,EAAC;;;SACN;QAED,uCAAiB,GAAjB,UAAkB,CAA4B;YAC1C,IAAI,IAAI,GAAY,IAAI,CAAC;YACzB,IAAI,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,GAAG,CAAC,EAAE,EAAE,2BAA2B;gBAC5D,IAAI,GAAG,IAAI,CAAC,aAAa,CAAC,GAAG,EAAE,CAAC;aACnC;iBAAM,EAAE,mDAAmD;gBACxD,IAAI,GAAG,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC;gBACrB,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;aACxB;YACD,OAAO,IAAI,CAAA;QACf,CAAC;QAGD,2BAAK,GAAL,UAAM,IAAa;YACf,IAAI,OAAO,GAAY,IAAI,CAAC;YAC5B,IAAI,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,GAAG,CAAC,EAAE,EAAE,2BAA2B;gBAC5D,OAAO,GAAG,IAAI,CAAC,aAAa,CAAC,GAAG,EAAE,CAAC;aACtC;iBAAM,EAAE,mDAAmD;gBACxD,OAAO,GAAG,EAAE,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;aAClC;YACD,OAAO,OAAO,CAAC;QACnB,CAAC;QAED,QAAQ;QACR,8BAAQ,GAAR,UAAS,IAAa;YAClB,sBAAsB;YACtB,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,oDAAoD;QACtF,CAAC;QACD,OAAO;QACP,+BAAS,GAAT;YACI,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,CAAC;QAC/B,CAAC;QAEL,kBAAC;IAAD,CA5DA,AA4DC,IAAA;IA5DY,uBAAW,cA4DvB,CAAA;AACL,CAAC,EA3LgB,WAAW,GAAX,mBAAW,KAAX,mBAAW,QA2L3B","file":"","sourceRoot":"..\\..\\..\\..\\..\\assets\\Script\\common","sourcesContent":["import { Units } from \"./units\";\r\nexport namespace AssetLoader {\r\n    export class PreAsset {\r\n        url: string;\r\n        type: typeof cc.Asset;\r\n        asset: any;\r\n        constructor(url?: string, type?: typeof cc.Asset, asset?: any) {\r\n            this.url = url;\r\n            this.type = type;\r\n            this.asset = asset;\r\n        }\r\n    }\r\n\r\n    export class PreLoader {\r\n        //缓存资源列表单例\r\n        private preItems: Units.List<PreAsset> = Units.Single.getInstance<Units.List<PreAsset>>(Units.List);\r\n        //当前添加的资源请求项\r\n        private _items: Units.List<PreAsset> = new Units.List<PreAsset>();\r\n        /**\r\n         * 当前进度\r\n         */\r\n        private curprocess: number = 0;\r\n        /**\r\n         * 进度改变回调函数\r\n         */\r\n        private onProcess: (curprocess: number, total: number) => void = null;\r\n\r\n        constructor(process?: (curprocess: number, total: number) => void) {\r\n            if (process) this.onProcess = process;\r\n        }\r\n        /**\r\n         * 根据路径获取资源\r\n         * @param url 资源路径\r\n         */\r\n        get<T>(url): T {\r\n            let result = this.preItems.firstOrDefault(item => item.url == url);\r\n            return result ? result.asset : null;\r\n        }\r\n        /**\r\n         * 添加预加载资源项\r\n         * @param url 预加载项的路径\r\n         * @param type 预加载项的类型\r\n         */\r\n        addPreItem(url: string, type: typeof cc.Asset) {\r\n            //查询数组中是否有资源路径的项目\r\n            let result = this._items.firstOrDefault(item => item.url == url);\r\n            //防止添加重复资源\r\n            if (!result) this._items.add(new PreAsset(url, type));\r\n        }\r\n        /**\r\n         * 开始预加载\r\n         */\r\n        async start(): Promise<null> {\r\n            return new Promise((resolve, reject) => {\r\n                this.curprocess = 0;\r\n                let load: Units.List<PreAsset> = new Units.List<PreAsset>();\r\n                for (const item of this._items) {\r\n\r\n                    let res = this.preItems.firstOrDefault(i => i.url == item.url);\r\n                    //如果此类资源存在 进度+1\r\n                    if (res && res.asset !== undefined && res.asset !== null) this.curprocess++;\r\n                    else load.add(item);\r\n                }\r\n                //是否有进度改变回调函数\r\n                if (this.onProcess) this.onProcess(this.curprocess, this._items.length);\r\n                if (this.curprocess == this._items.length) resolve();\r\n                else {\r\n                    for (let item of load) {\r\n                        LoaderProxy.get<typeof item.type>(item.url, item.type).then((res) => {\r\n                            //当前进度+1\r\n                            this.curprocess++;\r\n                            //是否有进度改变回调函数\r\n                            if (this.onProcess) this.onProcess(this.curprocess, this._items.length);\r\n                            //当前进度是否等于总请求数  =则执行完成回调函数\r\n                            if (this.curprocess == this._items.length) resolve();\r\n                        })\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * 系统资源加载代理\r\n     */\r\n    export class LoaderProxy {\r\n        //缓存资源列表单例\r\n        static preItems = Units.Single.getInstance<Units.List<PreAsset>>(Units.List);\r\n        /**\r\n         * 根据url获取游戏资源\r\n         * @param url 资源URL\r\n         * @param c 资源类型\r\n         */\r\n        static async get<T>(url: string, c: typeof cc.Asset): Promise<T> {\r\n            return new Promise((resolve, reject) => {\r\n                //let preItems = Single.getInstance<List<PreAsset>>(List);\r\n\r\n                //根据路径在资源缓存列表中是否能找到资源\r\n                let result = this.preItems.firstOrDefault(item => item.url == url);\r\n                if (result && result.asset != undefined && result.asset != null) {\r\n                    //找到资源直接返回\r\n                    resolve(result.asset);\r\n                } else {\r\n                    //找不到资源 根据路径向服务器获取资源\r\n                    cc.loader.loadRes(url, c, (error, res: T) => {\r\n                        let data = this.preItems.firstOrDefault(item => item.url == url);\r\n                        //如果资源缓存列表中没有此数据\r\n                        if (data) {\r\n                            //有此类资源  替换资源\r\n                            data.asset = res;\r\n                        } else {\r\n                            //无此类资源  添加资源\r\n                            this.preItems.add(new PreAsset(url, c, res));\r\n                        }\r\n                        if (error) {\r\n                            reject(error);\r\n                        } else {\r\n                            resolve(res);\r\n                        }\r\n                    })\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 对象池工厂\r\n     */\r\n    export class FactoryPool {\r\n        private _factorypPool: cc.NodePool;\r\n\r\n        constructor() {\r\n            this._factorypPool = new cc.NodePool();\r\n        }\r\n        /**\r\n         * 异步创建节点对象\r\n         * @param url 节点资源url\r\n         * @param c 资源类型\r\n         */\r\n        async acyncCreate<T>(url: string, c: typeof cc.Asset): Promise<cc.Node> {\r\n            return new Promise<cc.Node>((resolve, reject) => {\r\n                let tObj = null;\r\n                if (this._factorypPool.size() > 0) { // 通过 size 接口判断对象池中是否有空闲的对象\r\n                    tObj = this._factorypPool.get();\r\n                    resolve(tObj);\r\n                } else { // 如果没有空闲对象，也就是对象池中备用对象不够时，我们就用 cc.instantiate 重新创建\r\n                    LoaderProxy.get<T>(url, c).then((res) => {\r\n                        tObj = cc.instantiate(res);\r\n                        resolve(tObj);\r\n                    }, (error) => {\r\n                        reject(error);\r\n                    })\r\n                }\r\n            });\r\n        }\r\n\r\n        createNodeByAsset(c: typeof cc.RenderComponent): cc.Node {\r\n            let tObj: cc.Node = null;\r\n            if (this._factorypPool.size() > 0) { // 通过 size 接口判断对象池中是否有空闲的对象\r\n                tObj = this._factorypPool.get();\r\n            } else { // 如果没有空闲对象，也就是对象池中备用对象不够时，我们就用 cc.instantiate 重新创建\r\n                tObj = new cc.Node();\r\n                tObj.addComponent(c);\r\n            }\r\n            return tObj\r\n        }\r\n\r\n\r\n        clone(node: cc.Node): cc.Node {\r\n            let newnode: cc.Node = null;\r\n            if (this._factorypPool.size() > 0) { // 通过 size 接口判断对象池中是否有空闲的对象\r\n                newnode = this._factorypPool.get();\r\n            } else { // 如果没有空闲对象，也就是对象池中备用对象不够时，我们就用 cc.instantiate 重新创建\r\n                newnode = cc.instantiate(node);\r\n            }\r\n            return newnode;\r\n        }\r\n\r\n        //回收节点对象\r\n        onKilled(node: cc.Node) {\r\n            // enemy 应该是一个 cc.Node\r\n            this._factorypPool.put(node); // 和初始化时的方法一样，将节点放进对象池，这个方法会同时调用节点的 removeFromParent\r\n        }\r\n        //清空对象池\r\n        clearPool() {\r\n            this._factorypPool.clear();\r\n        }\r\n\r\n    }\r\n}"]}